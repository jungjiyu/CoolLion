Jackson 라이브러리는 기본 생성자를 필요로 한다. @NoArgContructor 를 항상 붙이라는겨??


system 설정하는게 더 빠르다.
	system으로 설정하고 게시글만 쿼리함>> 749ms
	게시글만 쿼리함>> 1229ms


API 통신 방법
	: https://velog.io/@limehee/Spring-WebClient%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-API-%ED%98%B8%EC%B6%9C-%EA%B0%9C%EC%84%A0
	: 아래 3가지 다 Http Client. 다른 서버로 request 할 수 있게 한다.
******(0) WebClient
		: 스프링 5부터 도입된 비동기 및 반응형 프로그래밍을 지원하는 HTTP 클라이언트
		: RestTemplate보다 현대적
		: OkHttp보다 스프링과의 통합이 잘 되어 있어 더 편리

	(1) RestTemplate 
		: 기본적으로 매번 의존성 추가하는 Spring Boot Web 에 포함되어있음
	(2) OkHttp



동기 비동기 블록킹 넌블록킹
	: https://musma.github.io/2019/04/17/blocking-and-synchronous.html
	: 쉽게 말하면 블럭/논블럭개념 ⊂ 동기/비동기개념
	:  동기/비동기 >> 작업의 순서

		: 동기(synchronous) >> 요청과 결과가 동기적이다. 요청을 보낸 후 응답을 받아야 다른 동작 실행된다.
		: 비동기(asynchronous) >> 요청과 결과가 비동기적이다. 요청을 보낸 후 응답을 아직 받지 않았더라도 다른 동작을 실행 가능하다.


	:  블록킹/넌블록킹 >> 제어권
		: Blocking >>  호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 바로 돌려주지 않는다
		: Non-Blocking >> 호출된 함수가 자신이 할 일을 마치지 않았더라도 바로 제어권을 건네주어(return) 호출한 함수가 다른 일을 진행할 수 있도록 해준다 



idle :  대기 상태에 있는(실행되지 않고 있는) 것. 
	: 통합 개발 환경 IDE 랑 전혀 다른 개념임



폴링 Polling: 주기적으로 체크하는 방식

Tomcat의 Connector :  Servlet Container가 외부와 소통할 수 있게 함
	: https://velog.io/@jihoson94/BIO-NIO-Connector-in-Tomcat
	: 종류 >> 기존엔 BIO 썼었으나 현재는 NIO 쓴다. 따라서 비동기 작업이 가능하다.
		(1) BIO (Blocking I/O) : 하나의 스레드가 하나의 I/O 작업을 동기적으로 처리.
			: Connector 내부에서 각 요청 마다 바로 Thread를 (Woker Thread Pool에서 꺼내) 할당해 처리시키고, 각 스레드는 해당 작업이 완료될 때까지 block 된다. 그러니까 외부에 복잡한 작업 시켰을 때 해당 스레드는 멍청하게 놀고 있는거다.
			: 현재 depreceated 됨

		(2) NIO (Non-blocking I/O) : 하나의 스레드가 여러 I/O 작업을 처리. 비동기적.
			:  Connector 내부에서 요청들을 모두 하나의 Thread(Poller)가 관리하게 된다. 이 Thread(poller)는 처리가 가능한 순간(데이터 준비가 된순간. 그러니까 외부에 복잡한 작업 시키고 결과를 얻은 상태.)에만 request 를 thread를 할당한다. 처리가 불가능한 순간(외부에 복잡한 작업 시켰을때)엔 해당 스레드에서 다른 요청 작업을 처리하게 한다.
			:  thread idle 상태를 줄이고 데이터를 이용할 수 있을 때만 Thread를 사용하기 때문에 더 많은 Thread를 즉, 더 많은 동시 사용자의 요청을 처리 가능
			: 현재 얘를 채택.


servlet : tomcat 과 마찬가지로 처음엔 blocking 방식만 지원했으나 이젠 non-blocking 도 지원.


Spring MVC의 동작 방식 : 현재에도 blocking 하게만 작동.  따라서 동기적 처리만 가능. DispatcherServelt 때문에.
	: Spring MVC >> servlet 기반. >>  thread pool 기반
	: 아무리 Tomcat , Servlet이 NIO 로 요청을 비동기적으로 처리한다고 해도, MVC에선 Asynchronouse/Non-blocking 하게 작동되지 않음. 
	: DispatcherServelt 내부에서 사용되는 HttpServletRequest, HttpServletResponse는 In/OutputStream 을 상속받는데, 이  In/OutputStream 은 Blocking 하게 동작이 되는 얘들임.
	:  @Async 또는 completedfuture 등을 사용하여 내부적으로 비동기 방식을 구현할 수 있으나, 실제 사용자의 요청 자체에 대해선 Synchronouse 즉 동기적인 처리가 이뤄지고 이를 어케 손볼 수는 없다. 
	: https://velog.io/@akfls221/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-NonBlocking-Blocking%EA%B3%BC-%EC%9B%B9-%EC%84%9C%EB%B2%84%EC%9D%98-%EA%B4%80%EA%B3%84	



Traditional Data Proccessing 전통적인 데이터 처리 방식 : request 의 페이로드 데이터, 응답을 위한 데이터들을 모두 메모리에 저장 후 사용자에게 응답을 보냄. 
	: 한 요청 처리 위해 다량의 데이터를 메모리에 저장해야됨. 

Stream Proccessing : 최대한 지금 당장 처리해야되는 데이터만 메모리에 저장시키고, 사용자에게 응답을 보냄.
	: 크기가 작은 시스템 메모리로도 많은 양의 데이터를 처리 가능. 
	



Publisher 와 Subscriber :
	Publisher (= Subject = Observable = Producer): 이벤트 발행하는 대상
	Subscriber(= Observer = Consumer) : 이벤트를 consume 하는 대상


Push 방식. : Publisher 가 Subscriber 에게 이벤트를 보내는 방식
	:  Publisher 가 n개의 이벤트를 보내는 속도보다 Subscriber 가 n개의 이벤트를 처리하는 속도가 느리다면, Subscriber는 대기하는 이벤트를 위한 Queue를 두어야됨.
		: 이때 Queue 사이즈 이상으로 이벤트가 발생한다면, 신규로 수신된 메시지를 거절함. 그리고 거절된 메세지는 이후 재요청하게 되고, 이 과정에서 네트워크와 cpu 연산 비용 추가 발생. >> 비효율적


Pull 방식 :  Subscriber가 자신이 수용할 수 있는 만큼만 Publisher에게 Event를 요청하는 방식
	: Publisher는 요청받은 만큼만 전달하면 되고, Subscriber는 더 이상 ‘Out of Memory’ 에러를 걱정하지 않아도 됨.
	: 다이나믹 풀 방식 : 말 그대로 동적인 풀 방식. 현재 상태따라 Subscriber가 다양한 크기의 이벤트를 요청하는 것.	


BackPressure 백프레셔 : 데이터 스트리밍 환경에서 다이나믹 풀 방식으로  데이터 흐름을 조절하는 메커니즘
	: 그러니까 pull 방식처럼 데이터의 전달이 subscriber 의 요구에 따라 조절된다는 것.
	: BackPressure 란 이름은, 반대로 압력을 넣는 다는 의미. 그러니까 subscirber 가 제공자인 publisher 에게 거꾸로 요청하는 방식에서 유래한것.


Reactive Streams: 비동기 데이터 스트림을 효율적으로 처리하기 위한 표준.
	: 특히 back pressure를 채택
	; 비동기 thread 경계 사이로 스트림 데이터의 교환을 관리
		:  생산자와 소비자가 서로 다른 스레드에서 동작하는 경우, 둘 사이의 데이터 교환을 안정적이고 유연하게 관리해준다는 것.

	: 비동기 시스템에서 사이즈가 정해져있지 않은 데이터 스트림들을 다룰 때, 전달되는 데이터 자원의 양이 도착지에서 처리가능한양을 압도하지 않게 하기 위한 제어가 필요하고, 이를 위해 백프래셔를 채택한 것.


Reactive Programming :  이벤트 대한 반응 중심의 프로그래밍 패러다임
	:  이벤트 >> "비동기 작업(주로 I/O 작업 완료, 타이머 만료, 사용자 입력 등)의 완료 신호"
	:  작업이 완료되길 기다리기보단, 이벤트가 감지되면 반응함.
	: Reactive Streams를 사용하여 비동기 데이터 스트림을 관리
		: publisher 과 subscriber 가 같은 thread 에 있을 필요가 없게 됨 >> thread 사용율 개선
	: 동시성 Concurrency
		: 
	

콜백 ; 특정 이벤트가 발생했을 때 실행될 함수


Thread per request VS EventLoop Model 
	: https://velog.io/@jihoson94/EventLoopModelInSpring
	: https://dev-jj.tistory.com/entry/Spring-WebFlux-EventLoop-Non-Blocking
	: Thread per request >>  각 Request마다 Thread 를 할당해 처리하는 모델.
		: Blocking IO처리를 할 때 "해당" Thread는 아무것도 하지않고 대기상태. 논다.
			: 해당 IO 처리가 끝날 때까지 그 Thread 는 놀고 있는 상태이므로 비효율적이다.
			: 헷갈리지 말아야할 것>> thread 간은 비동기적임. 그러니까 threadA 가 blocking 작업 실행하고 있다해도 , threadB 는 다른 작업을 수행 가능하다.


	: EventLoop Model >> 이벤트 기반 비동기 작업을 효율적으로 처리하는 모델
		: Reactive Programming에서 활용될 수 있는 모델 중 하나
		: 이벤트 >> "비동기 작업(주로 I/O 작업 완료, 타이머 만료, 사용자 입력 등)의 완료 신호"
		: EventLoop
		    : 말 그대로 이벤트 감지를 위해 loop 를 계속 돌리고 , 이벤트를 감지하면 해당 이벤트에 대한 작업을 수행한다는거다.
		    : 특징 
			: 단일 스레드에서 동작
			: 이벤트 발생시, 이벤트 큐Event queue 에 해당 이벤트와 (해당이벤트와연결된) 콜백함수를 추가
			: 이벤트 루프에서 이벤트를 하나씩 꺼내 처리. 즉 해당 이벤트와 연결된 콜백함수 실행시킴.

		: 비동기작업 지원을 위해 Netty, Node.js 등 플랫폼에서 사용된다.
		******: 주의 >> Tomcat 은 EventLoop 모델이 아닌, 전통적인 스레드 기반 모델을 기반으로 NIO 를 사용해 비동기 처리를 제공한다.


Spring Reactive Stack: Asynchronose/Non-blocking한 애플리케이션 구현을 가능하게 함
	: 기존 (DispatcherServlet , getParameter , Filter 등등의.  ) 동기 처리 방식으로 인한 한계를 극복하고자 탄생됨
 		: DispatcherServlet만 문제가 있는건 아니고 여러가지 두루두루 문제가 많은데 그중 대표적인게 DispatcherServlet인것.




Spring WebFlux : reactive 스타일의 어플리케이션 개발을 도와주는 모듈 
	: reactive programming 방식을 사용
	:  Spring version 5.0부터 추가됨	
	: WebFlux의 대표적 라이브러리
		(1) 함수형이며 fluent API들을 제공하는 HTTP 요청들을 위한 reactive를 포함
		(2) Non-blocking client인 WebClient를 포함
	: 전통적인 annotation기반의 프로그래밍 모델을 함수형 라우팅을 가지고 확장한 것
	: 비동기 및 반응형 프로그래밍 모델을 지원하기 위해 Reactive Streams API와 HTTP runtimes를 결합 >> HTTP 서버 런타임과의 호환성을 확보하면서도 반응형 스트림을 효율적으로 처리
		: Reactive Streams API >> 스트림 데이터의 비동기 처리를 효율적으로 관리하기 위한 표준
		: HTTP runtimes >> HTTP 요청과 응답을 처리하는 서버 환경 또는 컨테이너		
			: Reactive Streams API 처럼 import 해서 쓰는 그런 개념이 아님
			: Netty, Tomcat 등
			: WebFlux는 default로 (tomcat이 아닌) Netty를 사용. 
				:  spring mvc는 thread pool 기반이고 반면에 spring-webflux는 event-loop 메커니즘 기반
				: Tomcat같은 전통적인 Servlet Container에서도 지원되긴 함. 근데 Netty 를 사용할 때에 비해 많은 thread 가 사용됨
				; https://velog.io/@akfls221/Netty 





Netty >>비동기 이벤트 기반 네트워크 애플리케이션 프레임워크
	; Event Loop 모델을 사용하여 비동기 처리를 구현
		: EventLoopGroup >> 하나 이상의 EventLoop 를 (지속적으로) 관리. 새롭운 Channel을 Event Loop에 할당해줌.
	: Tomcat 은 NIO를 도입하여 추가적으로 비동기 작업을 지원하는 느낌이었다면 Netty 는 아예 첨부터 비동기 작업에 중점을 둔 느낌이다.







spring-boot-starter-web 과 spring-boot-starter-webflux 를 동시에 사용해도 될까 ? >> oo
    : 동시에 사용해도된다. 알잘딱깔센 적이게, 전체적인 설정은 spring mvc 가 적용되면서 webflux 의 유용한 기능(webclient .. ) 는 그대로 사용할 수 있다
 	: Spring Boot는 spring-boot-starter-web과 spring-boot-starter-webflux가 모두 포함된 경우, 기본적으로 Spring MVC를 사용하도록 설정하면서도, WebClient를 사용할 수 있도록 필요한 빈을 자동으로 구성하기 떄문.


스프링의 종류와 자동설정
	: 스프링의 웹 프레임워크 종류
		(1) WebMVC: 전통적인 멀티 쓰레드 기반의 웹 프레임워크 << spring-boot-starter-web
		(2) WebFlux:  리액티브 스택 기반의 웹 프레임워크<<  spring-boot-starter-webflux 

	: 스프링의 애플리케이션 타입
	    : 애플리케이션의 실행 시점에서, 클래스 패스를 기반으로 다음 3가지 중 "하나"로 선택된다.
		: spring-boot-starter-web 과 spring-boot-starter-webflux 의존성이 모두 존재할 경우 SERVLET타입이 채택된다.
		(1) NONE: 웹 애플리케이션이 아닌 경우
		(2) SERVLET: 서블릿 웹 애플리케이션인 경우
		(3) REACTIVE: 리액티브 웹 애플리케이션인 경우

	: 자동설정 
		: 애플리케이션의 타입에 따라 자동설정이 진행된다.
			:  spring-boot-starter-web 과 spring-boot-starter-webflux 의존성이 모두 존재할 경우 타입이 SERVLET 이 되므로 일반적으로 WebFlux 관련 자동설정은 활성화되지 않는다. 
				:  Spring MVC으로 Application이 구성되기 때문에 DispatcherServlet, ThreadPoolExecutor, Controller bean이 여전히 존재한다.
				: 참고로 @EnableWebFlux 를 사용하여 WebFluxAutoConfiguration를 강제 활성화 시킬 수 있긴하다...
 
		: 자동설정을 "활성화"하는 클래스
			(1) SERVLET 타입인 경우 >> WebMvcAutoConfiguration
			(2) REACTIVE 타입인 경우 >> WebFluxAutoConfiguration

		: https://velog.io/@kny8092/spring-boot-starter-web%EA%B3%BC-webflux%EB%A5%BC-%EB%8F%99%EC%8B%9C%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C%ED%95%A0%EA%B9%8C
		: https://mangkyu.tistory.com/257
		: https://stackoverflow.com/questions/51377675/dont-spring-boot-starter-web-and-spring-boot-starter-webflux-work-together
		: https://docs.spring.io/spring-boot/docs/2.1.13.RELEASE/reference/html/boot-features-developing-web-applications.html#:~:text=Adding%20both%20spring%2Dboot%2Dstarter,to%20use%20the%20reactive%20WebClient%20.
		
		: spring-boot-starter-web >> 기본적인 spring mvc 프로젝트 생성 위해 필요
		: spring-boot-starter-webflux  >> webclient 사용 위해 필요




RestTemplate >> Multi-Thread와 Blocking 방식으로 요청 처리한다
	: 작동 방식
		1. 어플리케이션 구동 시점에 Thread Pool 생성
		2. (타 서버로 보낼) request는 먼저 Queue에 쌓임
		3. 가용한 쓰레드가 있음 해당 request 를 그 쓰레드에 할당
			: 1요청 당 1스레드가 할당
			: 가용한 쓰레드가 생길때까진 Queue에서 대기
		4. 각 쓰레드는 Blocking 방식으로 처리됨
			:  응답이 받을때까지 그 스레드는 다른 요청에 할당 될 수 없음
	: 가용한 쓰레드수가 적으면, 결국 전체 서비스는 매우 느려지게 되어 Spring 커뮤니티에서는 RestTemplate을 이미 Depreciated시키고 WebClient를 사용할것을 강력히 권고함.




webclient >> Single Thread와 Non-Blocking 방식 요청 처리
	: https://gngsn.tistory.com/154
	: https://velog.io/@da_na/WebClient-WebClient-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%EC%99%B8%EB%B6%80-API-%ED%98%B8%EC%B6%9C%ED%95%98%EA%B8%B0
	: https://devahea.github.io/2019/04/21/Spring-WebFlux%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%81%EC%9D%80-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A1%9C-%EB%A7%8E%EC%9D%80-%ED%8A%B8%EB%9E%98%ED%94%BD%EC%9D%84-%EA%B0%90%EB%8B%B9%ED%95%A0%EA%B9%8C/
	: https://leeggmin.tistory.com/11
	: 적은 리소스로 많은 트래픽을 감당한다.
	: "이벤트" 반응형이다.
		: webclient에서의 "이벤트" >> 비동기 요청/응답, 데이터 스트림의 변화 등과 같은 비동기 작업과 상태 변화. 
			: 프론트단의 마우스클릭과 같은 사용자 이벤트를 말하는게 아님 주의.

		: 반응성, 탄력성, 가용성, 비동기성을 보장하는 Spring React 프레임워크를 사용함
		: React Web 프레임워크인 Spring WebFlux 에서 Http Client로 사용됨

	: 작동 방식
		1. 각 요청은 Event Loop 내에 Job으로 등록됨
		2. Event Loop는 각 Job을 publisher 에게 요청한 후, 결과를 기다리지 않고 다른 Job을 처리

	: 사용방법
		step 1. https://gngsn.tistory.com/154
		step 2. https://gngsn.tistory.com/198
		: request body 설정하기
			(1) bodyValue( Object ) : 단순하고 간편하게 요청 본문을 설정
			(2) body(BodyInserters.fromValue( Mono<Object> ) ) : 선택적으로 요청 본문을 구성

		: response body 받아오기
			: retrieve() : body를 받아 디코딩하는 간단한 메소드
		: retrieve 이후에 사용 가능한 메서드
		   1. status, headers, body를 포함하는 ResponseEntity 타입으로 반환
			: toEntity()
		   2. body의 데이터로만 받음
			(1) toMono() :  최대 하나의 결과를 예상할 때 사용
			(2) toFlux() : 여러 결과가 예상되는 경우 사용

	 	: 외부 API 에러 처리하기
.onStatus(HttpStatus::is4xxClientError, response -> ...)
Event
	: Event-Driven Programming>> 프로그램 실행 흐름이 이벤트에 의해 결정되는 프로그래밍 패러다임
		: 여기서의 이벤트는 프론트 단의 마우스 클릭 등과 작업완료와 같은 백엔드 단의 이벤트 모두를 일컬어 말하는거다.
	: 이벤트를 감지하는 원리 
		: Event 감지하는 Loop를 계속 돌리고, Event를 감지하면 적합한 handler 에게 해당 handler 가 해당 event 에 바인딩된 콜백을 실행하게한다.
	; https://devahea.github.io/2019/04/21/Spring-WebFlux%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%81%EC%9D%80-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A1%9C-%EB%A7%8E%EC%9D%80-%ED%8A%B8%EB%9E%98%ED%94%BD%EC%9D%84-%EA%B0%90%EB%8B%B9%ED%95%A0%EA%B9%8C/


Chat completions Api : 일반적으로 생각되는 chatGPT 기능( 자연어처리 챗봇)을  제공하는 api.
	: https://kanoos-stu.tistory.com/87
	: 엔드포인트 >> https://api.openai.com/v1/chat/completions
	: request 
		: request header 형식
		    : 필수
			: Authorization >>챗지피티api키를 인증으로 사용
				:  " Bearer 챗지피티api키"의 형식
 
		: request body 형식
		    : 필수
			(1) model >> 사용할 모델명시
				: "gpt-4o" , "gpt-3.5-turbo" ... 와 같은 문자열값

			(2) messages >> 
				: {"role": "system", "content": "챗봇초기지침과설정내용"} , {"role": "user", "content": "질문내용"} 과 같은 객체를 요소로 하는 배열
				: 객체의 role 과 content 속성은 필수적.
					1. role : system , user, assistant 중 하나 가능
						: 한 messages 배열에 같은 role 을 가지는 객체를 여러개 담을 수도 있다.
						(1) user >> 사용자. 챗봇에게 질문하는 대상.
							: 해당 객체의 content 속성에 질문할 내용을 담게된다.
							: messages는 이 role 을 가지는 객체를 필수적으로 요소로 가져야됨. (role 이 system 이거나 assistant 인건 걍 옵션임 )

						(2) system >> 챗봇 관리자. 
							: 해당 객체의 content 속성에 챗봇초기지침내용을 담게 된다.
							: 필수적이진 않다

					2. content : 챗지피티가 받을 내용을 담는다.
						: role 에 따라 담을 수 있는 내용이 다르다
				: 예시
  				  "messages": [
    				    {
      				      "role": "system",
      				      "content": "당신은 웨이트 트레이닝 전문가입니다."
      				  },
      				  {
       				     "role": "user",
        				    "content": "둔근을 키울 수 있는 운동을 추천해주세요."
      				  }
   				 ]


		    : 옵션
			(1) max_tokens : 응답될 문장의 최대 토큰 수를 제어한다.
				: 참고 >> 토큰 수 확인 사이트 : https://platform.openai.com/tokenizer
			(2) user : 요청을 보낸 사용자를 식별하는 데 사용
			(3) temperature 
			(4) top_p  
			(5) n 
			(6) stream  
			(7) stop  
			(8) presence_penalty   
			(9) frequency_penalty   
			(10) logit_bias   


		: 종합 예시

curl https://api.openai.com/v1/chat/completions \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $OPENAI_API_KEY" \
  -d '{
    "model": "gpt-4o",
    "messages": [
      {
        "role": "system",
        "content": "assistant지시사항"
      },
      {
        "role": "user",
        "content": "컨텐츠내용1"
      },
      {
        "role": "user",
        "content": "컨텐츠내용2"
      }
    ]
  }'


	: response
{
  "id": "chatcmpl-123",
  "object": "chat.completion",
  "created": 1677652288,
  "model": "gpt-3.5-turbo-0125",
  "system_fingerprint": "fp_44709d6fcb",
  "choices": [{
    "index": 0,
    "message": {
      "role": "assistant",
      "content": "\n\nHello there, how may I assist you today?",
    },
    "logprobs": null,
    "finish_reason": "stop"
  }],
  "usage": {
    "prompt_tokens": 9,
    "completion_tokens": 12,
    "total_tokens": 21
  }
}



gpt 와 spring boot 연동

	step 1. application.properties >> 일단 필수적으로 key 는 저장해두자.
#gpt-4
openai.api.key=키복붙
openai.model=gpt-4o
openai.api.url= https://api.openai.com/v1/chat/completions

	step 2. gpt에게 request 될 dto 생성
		: 필수 필드 
			(1)
			(2)
